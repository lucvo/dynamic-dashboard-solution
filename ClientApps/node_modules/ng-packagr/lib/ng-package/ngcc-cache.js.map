{"version":3,"file":"ngcc-cache.js","sourceRoot":"","sources":["../../../src/lib/ng-package/ngcc-cache.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;GASG;AACH,MAAa,mBAAmB;IAAhC;QACmB,yBAAoB,GAAG,IAAI,GAAG,EAAU,CAAC;IAa5D,CAAC;IAXC,YAAY,CAAC,UAAkB;QAC7B,OAAO,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IACnD,CAAC;IAED,aAAa,CAAC,UAAkB;QAC9B,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IAC5C,CAAC;IAED,KAAK;QACH,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,CAAC;IACpC,CAAC;CACF;AAdD,kDAcC","sourcesContent":["/**\n * Registers the absolute specifiers of libraries that have been processed by ngcc. This cache is\n * reused across all entry-points of a package, so module requests across the entry-points can\n * determine whether invoking ngcc is necessary.\n *\n * The cost of invoking ngcc for an entry-point that has already been processed is limited due to\n * a fast path in ngcc, however even in this fast-path does ngcc scan the entry-point to determine\n * if all dependencies have been processed. This cache allows to avoid that work, as entry-points\n * are processed in batches during which the `node_modules` directory is not mutated.\n */\nexport class NgccProcessingCache {\n  private readonly processedModuleNames = new Set<string>();\n\n  hasProcessed(moduleName: string): boolean {\n    return this.processedModuleNames.has(moduleName);\n  }\n\n  markProcessed(moduleName: string): void {\n    this.processedModuleNames.add(moduleName);\n  }\n\n  clear(): void {\n    this.processedModuleNames.clear();\n  }\n}\n"]}